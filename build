#!/usr/bin/env ruby

#
# Copyright (C) 2014 Noralf Tronnes
#
# MIT License
#

require 'pp'

begin
  require 'rubygems'
  gem 'rake'
rescue LoadError
end

require 'time'
require 'open-uri'
require 'json'
require 'rake'
require 'tempfile'

require_relative 'git'


def info(msg)
  $stdout.puts msg
end

def debug(msg)
  $stderr.puts msg if Rake.application.options.trace
end

# Lazy environment variable expansion
# stores the value in workdir for later runs
class VAR
  @@defaults = {}

  class << self
  def read(var)
    fn = workdir "#{var}.variable"
    if File.exists? fn
      File.read fn
    else
      nil
    end
  end

  def write(var, value)
    fn = workdir "#{var}.variable"
    File.open(fn, 'w') { |file| file.write value }
  end

  def [](var)
    if ENV.key? var
      debug "#{var} == #{ENV[var]}"
      return ENV[var]
    end
    value = self.read var
    unless value == nil
      info "#{var} <= #{value}"
      ENV[var] = value
      return value
    end
    if @@defaults.key? var
      value = @@defaults[var].call
      info "#{var} ?= #{value}"
      ENV[var] = value
      self.write var, value
    else
      debug "#{var} (not set)"
      nil
    end
  end

  def []=(var, value)
    info "#{var} = #{value}"
    ENV[var] = value
    self.write var, value
  end

  def delete(var)
    ENV.delete var
    fn = workdir "#{var}.variable"
    File.unlink fn if File.exists? fn
  end

  def default(var, &block)
    raise "block missing" unless block_given?
    @@defaults[var] = block
  end
  end
end

class LinuxVersion
  include Comparable

  attr_reader :version
  attr_reader :patchlevel
  attr_reader :sublevel
  attr_reader :extraversion

  def initialize(str)
    m = str.match /^(\d+)\.(\d+)\.(\d+)(.*)$/
    if m
      @sublevel = m[3].to_i
      @extraversion = m[4]
    else
      m = str.match /^(\d+)\.(\d+)$/
      raise "can't parse Linux kernel version number '#{str}'" unless m
      @sublevel = 0
      @extraversion = ""
    end
    @version = m[1].to_i
    @patchlevel = m[2].to_i
    @version_number = @version * 10**6 + @patchlevel * 10**3 + @sublevel
  end

  def <=>(other)
    self.to_i <=> other.to_i
  end

  def to_i
    @version_number
  end

  def to_s
    if @sublevel == 0
      "#{@version}.#{@patchlevel}"
    else
      "#{@version}.#{@patchlevel}.#{@sublevel}#{@extraversion}"
    end
  end

  class << self
    def parse_makefile(fn)
      makefile = File.read fn
      version = makefile.match(/VERSION = (\d+)$/)
      patchlevel = makefile.match(/PATCHLEVEL = (\d+)$/)
      sublevel = makefile.match(/SUBLEVEL = (\d+)$/)
      extraversion = makefile.match(/EXTRAVERSION =\s*(\w+)$/)
      unless version and patchlevel and sublevel
        raise "Can't extract the kernel version"
      end
      new "#{version[1]}.#{patchlevel[1]}.#{sublevel[1]}#{extraversion[1] if extraversion }"
    end
  end

end

def uname_m
  @uname_m ||= `uname -m`.strip
end

def cross_compile(name='CROSS_COMPILE')
  if uname_m == 'armv6l'
    ''
  else
    (name ? "#{name}=" : '') + workdir('tools/arm-bcm2708/arm-bcm2708-linux-gnueabi/bin/arm-bcm2708-linux-gnueabi-')
  end
end

def make(target='', pre='')
  "cd #{workdir 'linux'} && #{pre}ARCH=arm #{cross_compile} make #{target}"
end

def pre_install(str)
  File.open(workdir('pre-install'), 'a') { |file| file.write str }
end

def post_install(str)
  File.open(workdir('post-install'), 'a') { |file| file.write str }
end

module Readme
  def self.method_missing(method, *args, &block)
    if block_given?
      VAR.default "README_#{method}", block
    elsif method =~ /.*=$/
      VAR["README_#{method}".chop] = args.join
    else
      VAR["README_#{method}"]
    end
  end

  def self.clear(name)
    VAR.delete "README_#{name}"
  end

  def self.source(str=nil)
    VAR["README_source"] ||= ''
    if str.nil?
      VAR["README_source"]
    else
      VAR["README_source"] += str
    end
  end

  def self.patch(str=nil)
    VAR["README_patch"] ||= ''
    if str.nil?
      VAR["README_patch"]
    else
      VAR["README_patch"] += str
    end
  end

  def self.diffconfig
    diff = `cd #{workdir 'linux'} && scripts/diffconfig .config.defconfig .config`
    added = []
    changed = []
    deleted = []
    diff.each_line do |line|
      m = line.match(/ (\w+) (\S+) \-> (\S+)/)
      if m
        if m[2] == 'n'
          added << "* #{m[1]}=#{m[3]}"
        elsif m[3] == 'n'
          deleted << "* #{m[1]}"
        else
          changed << "* #{line.strip}"
        end
      else
        m = line.match(/([\+\-])(\w+) (\w)/)
        raise "can't parse diffconfig line: #{line}" unless m
        if m[1] == '+'
          unless m[3] == 'n'
            added << "* #{m[2]}=#{m[3]}"
          end
        else
          deleted << "* #{m[2]} #{m[3]}" unless m[3] == 'n'
        end
      end
    end
    added.sort!
    changed.sort!
    deleted.sort!
    str = ''
    str << "\n\nAdded:\n" unless added.empty?
    str << added.join("\n")
    str << "\n\nChanged:\n" unless changed.empty?
    str << changed.join("\n")
    str << "\n\nDeleted:\n" unless deleted.empty?
    str << deleted.join("\n")
    "```text\n" + diff + "\n```\n\n" + str
  end

  def self.write
    File.open(workdir('out/README.md'), 'w') { |file| file.write VAR['README_all'] }
  end
end

module Rake

  class Application
    # >=10.2.0 has exit_because_of_exception()
    alias_method :org_display_error_message, :display_error_message
    def display_error_message(ex)
      $exception_raised = ex
      org_display_error_message ex
    end
  end

  module DSL

    def find_patch_file(fn, ver, dir)
      [workdir(fn), download_dir(fn), "#{dir}/patches/#{fn}"].each { |f| return f if File.file? f }

      fl = FileList["#{workdir fn}/*"] + FileList["#{dir}/patches/#{fn}/*"]
      raise "can't find patch '#{fn}'" if fl.empty?
      patches = []
      fl.each { |f| patches << { :file => f, :ver => LinuxVersion.new(File.basename f) } }
      # favour workdir entries by removing duplicates
      patches.uniq! { |p| p[:ver].to_i }
      patches = patches.sort_by { |p| p[:ver].to_i }
      bestmatch = nil
      v = LinuxVersion.new(ver)
      patches.each do |p|
        break unless v >= p[:ver]
        bestmatch = p# if v >= p[:ver]
      end
      raise "can't find patch '#{fn}' that match '#{ver}'" unless bestmatch
      bestmatch[:file]
    end

    def patch(file, usegit=nil)
      dir = File.dirname caller[0][/[^:]*/]
      task :patch do
        print "Trying '#{file}'..."
        f = find_patch_file file, VAR['LINUX_KERNEL_VERSION'], dir
        if File.zero? f
          puts " skipped"
          next
        else
          puts
        end
        if usegit
          # doesn't always work without a git repository. Does work when 'git init' is done
          sh "cd #{workdir 'linux'} && git apply -v #{File.expand_path f}"
        else
          sh "cd #{workdir 'linux'} && patch -p1 < #{File.expand_path f}"
        end
        Readme.patch "* #{f}\n"
      end
    end

    def config(option, command, answer=nil)
      option = [option] unless option.is_a? Array
      cmd = []
      option.each do |k|
        value = ''
        case command
        when :enable, 'enable','e'
          c = '--enable'
        when :disable, 'disable', 'd'
          c = '--disable'
        when :module, 'module', 'm'
          c = '--module'
        when :str
          c = '--set-str'
          val = "\"#{answer}\""
          answer = nil
        when :val
          c = '--set-val'
          val = answer
          answer = nil
        when :undefine
          c = '--undefine'
        end
        cmd << "cd #{workdir 'linux'} && scripts/config #{c} #{k} #{val}"
      end

      if answer
        cmd << make('oldconfig', "yes #{answer} | ")
      else
        cmd << make('oldconfig', "yes \"\" | ")
      end

      task :config do
        cmd.each { |c| sh c }
      end
    end

    def http_get(url)
      begin
        r = open url
      rescue
        puts "could not get ${url}"
        raise
      end
      if r.meta['X-RateLimit-Remaining'] == "0"
        raise "Github API rate limit exceeded for #{url} (#{r.meta['X-RateLimit-Limit']} per hour)"
      end
      r.read
    end

    def github_get_head(repo, branch='master')
      url = "https://api.github.com/repos/#{repo}/git/refs/heads/master"
      j = JSON.parse http_get url
      begin
        sha = j['object']['sha']
      rescue
        puts "\n\n\n\n===>"
        puts j.inspect
        puts "<===\n\n    ERROR: bad response from #{url}\n\n"
        raise
      end
      sha
    end

    def github_tarball(repo, symlink, env_name=nil)
      env_name ||= repo.gsub(/[\/\-]/, '_').upcase
      VAR["#{env_name}_BRANCH"] ||= 'master'
      VAR["#{env_name}_SHA"] ||= github_get_head(repo, VAR["#{env_name}_BRANCH"])
      sha = VAR["#{env_name}_SHA"]
      saveas = "#{repo.gsub '/', '-'}-#{sha}.tar.gz"

      dl = download "https://github.com/#{repo}/archive/#{sha}.tar.gz", saveas, repo

      un = unpack saveas, symlink
      un.enhance [dl.name]
      return dl, un
    end

    def gitweb_get_head(repo, branch='master')
      # this is very slow on the Pi (~9s), only require when needed
      require 'rss'
      url = "#{repo};a=rss;h=refs/heads/#{branch}"
      feed = open(url) { |rss| RSS::Parser.parse(rss) }
      begin
        m = feed.items.first.link.match(/h=(.+)$/)
        m[1]
      rescue
        puts "\n\n\n\n===>"
        puts feed.inspect
        puts "<===\n\n    ERROR: bad response from #{url}\n\n"
        raise
      end
    end

    def gitweb_tarball(repo, symlink, ref=nil)
      ref ||= 'refs/heads/master'
      url = "#{repo};a=snapshot;h=#{ref};sf=tbz2"
      saveas = "#{repo}-#{ref}.tar.bz2".gsub(/.+:\/\//, '').gsub(/[^A-Za-z\d\._\-]/, '-')

      dl = download url, saveas, repo

      un = unpack saveas, symlink
      un.enhance [dl.name]
      return dl, un
    end

    def download(src, saveas=nil, desc=nil)
      saveas ||= File.basename(src)
      dst = download_dir saveas

      t = file dst do
        sh "wget --progress=dot:mega -O '#{dst}' '#{src}'"
      end
      target :fetch => dst do |t|
        if desc
          Readme.source "* [#{desc}](#{src})\n"
        else
          Readme.source "* #{src}\n"
        end
      end
      t
    end

    def unpack(fn, symlink=nil)
      src = download_dir fn
      # determine unpacking method
      # http://docs.openembedded.org/usermanual/html/src_uri_variable.html
      if %w{.tar .tgz .tar.gz .tar.Z .tar.bz2 .tar.xz}.any? { |ext| src.end_with? ext }
        cmd = "tar -x --checkpoint=100 --checkpoint-action=dot -C #{workdir} -f #{src}"
        list = "tar tf #{src} | sed -e 's@/.*@@' | uniq"
      elsif %w{.zip}.any? { |ext| src.end_with? ext }
        cmd = "unzip -q #{src} -d #{workdir}"
        list = "unzip -Z -1 #{src} | sed -e 's@/.*@@' | uniq"
      else
        raise "Don't know how to unpack #{src}"
      end

      dst_name = File.basename(fn, File.extname(fn))
      dst_name = File.basename(dst_name, File.extname(dst_name)) if File.extname(dst_name) == '.tar'
      symlink ||= dst_name
      t = file workdir(dst_name) do
        sh cmd
        puts
        # if we can list the contents of the archive, make a symlink to the first entry
        if list
          toplevel = `#{list}`.strip
          raise "Failed to rename unpacked archive (status = #{$?.to_i})" if $?.to_i != 0
          if toplevel != symlink
            cd workdir do
              ln_s toplevel, symlink, :verbose => true
            end
          end
        end
        # a marker to show that we have unpacked
        touch workdir(dst_name)
      end
      task :unpack => workdir(dst_name)
      t
    end

    def git(src, saveas)
      d = file download_dir(saveas) do
        cd download_dir do
          sh "git clone #{src} #{saveas}"
        end
      end
      task :fetch => download_dir(saveas)

      l = file workdir(saveas) do
        ln_s download_dir(saveas), workdir(saveas)
      end
      task :unpack => workdir(saveas)

      return d, l
    end

    def package(*args, &block)
      Rake::Package.define_task(*args, &block)
    end

    def target(*args, &block)
      Rake::TargetTask.define_task(*args, &block)
    end

    def release(*args, &block)
      Rake::ReleaseTask.define_task(*args, &block)
    end

  end

  class Package < Task
    def invoke_with_call_chain(task_args, invocation_chain)
      puts "Package: #{self.name}"
      super
    end
  end

  class TargetTask < Task
    # the first dependency is also a special target dependency
    def enhance(deps=nil, &block)
      if deps
          @target_dep = deps[0] if @prerequisites.empty?
          @prerequisites |= deps
      end
      @actions << block if block_given?
      self
    end

    # always run when using direct invocation 
    def invoke(*args)
      Rake::FileUtilsExt.verbose(!!Rake.application.options.trace) { Rake::FileUtilsExt.rm_f workdir name.to_s }
      super
    end

    # stop the invocation chain if timestamp is later than every
    # target in the target dependency chain
    def invoke_with_call_chain(task_args, invocation_chain)
      super if ! File.exist?(workdir name) or target_dep_timestamp > timestamp
    end

    def target_dep_timestamp
      @target_dep ||=nil
      if @target_dep
        td = application[@target_dep, @scope]
        if td.respond_to? 'target_dep_timestamp'
          stamp = td.target_dep_timestamp
          return stamp > timestamp ? stamp : timestamp
        end
      end
      timestamp
    end

    def timestamp
      if File.exist?(workdir name)
        File.mtime(workdir name.to_s)
      else
        Rake::EARLY
      end
    end

    def execute(args=nil)
      super
      Rake::FileUtilsExt.verbose(!!Rake.application.options.trace) { Rake::FileUtilsExt.touch workdir name.to_s }
      puts "Target '#{self.name}' done\n\n"
    end
  end

  class ReleaseTask < Task
    attr_reader :invoke_action

    # the first block runs before the dependencies
    # other actions as usual
    def enhance(deps=nil, &block)
      @prerequisites |= deps if deps
      if block_given?
        unless @invoke_action
          @invoke_action = block
        else
          @actions << block
        end
      end
      self
    end

    def invoke(*args)
      if @invoke_action
        # use application.trace in > 0.9.2
        $stderr.puts "** Execute #{name} (invoke_action)" if application.options.trace
        @invoke_action.call(self)
      end
      super
    end

    def invoke_with_call_chain(task_args, invocation_chain)
      puts "Release: #{self.name}"
      super
    end
  end
end


def workdir(file=nil)
  ENV['WORKDIR'] ||= File.join(Rake.application.original_dir, 'workdir')
  sh "mkdir -p #{ENV['WORKDIR']}" unless File.exists? ENV['WORKDIR']
  file ? File.join(ENV['WORKDIR'], file) : ENV['WORKDIR']
end

def download_dir(file=nil)
  ENV['DOWNLOAD_DIR'] ||= File.join ENV["RPI_BUILD_DIR"], 'downloads'
  sh "mkdir -p #{ENV['DOWNLOAD_DIR']}" unless File.exists? ENV['DOWNLOAD_DIR']
  file ? File.join(ENV['DOWNLOAD_DIR'], file) : ENV['DOWNLOAD_DIR']
end




##########################################################################################

# cd workdir/linux
# scripts/diffconfig .config.defconfig .config

# add first in the search path
$LOAD_PATH.unshift ENV["RPI_BUILD_DIR"]

begin
  STDOUT.sync = true
  STDERR.sync = true
  stdout_org = STDOUT.dup
  stderr_org = STDERR.dup

  Rake.application.standard_exception_handling do
    Rake.application.init
    if Rake.application.top_level_tasks and Rake.application.top_level_tasks[0] == "admin"
      load File.join File.dirname(__FILE__), 'admin.rake'
    else
      load File.join File.dirname(__FILE__), 'tasks.rake'
      Rake.application[:usage].invoke if Rake.application.top_level_tasks.empty?
      # run 'tasks.rake' tasks first if asked for
      Rake.application.top_level_tasks.reject! { |task_string|
        name, args = Rake.application.parse_task_string(task_string)
        t = Rake.application.lookup name
        if t
          t.invoke args
          true
        else
          false
        end
      }
      exit if Rake.application.top_level_tasks.empty?
      puts "Workdir: #{workdir}"
      load File.join File.dirname(__FILE__), 'targets.rake'
      Rake.application.load_rakefile
    end
  #  Rake::Task[:environment].invoke
  #  t = Rake::Task[:fbtft_master]
  #  t.execute
  #  t.invoke
    Rake.application.top_level
  end

ensure
  STDOUT.reopen stdout_org
  STDERR.reopen stderr_org
  if $logfile
    $logfile.puts "\nEnd: #{Time.now}\n\n"
    $logfile.close
    verbose(!!Rake.application.options.trace) { sh "cat #{$logfile.path} >> #{workdir("build.log")}" }
    $logfile.unlink
    # re-display, since it was caught by the logfile
    Rake.application.display_error_message($exception_raised) if $exception_raised
  end
end
